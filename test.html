<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  * {
    padding: 0;
    margin: 0;
  }
  html ,body {
   max-width: 750px;
   height: 100%;
   min-height: 100%;
   position: relative;
   margin: 0 auto;
   background-color: #fff;
  }
  #app {
    width: 100%;
    height: 100%;
    position: relative;
    box-sizing: border-box;
    border-right: 1px solid #ccc ;
    border-left: 1px solid #ccc ;
  }
</style>
<body>
  <div id="app">
       ssssssssssssss
       <button id="btn">点我</button>
       <input id="userName" type="text">
       <input id="sm" type="text">
  </div>
</body>
<script>
const  throttle1 = function (func,interval) {
  let lstTime =new Date().getTime(),
    nowTime ;
    return function (...args) {
      nowTime = new Date().getTime()
        if(nowTime-lstTime >=interval) {
          lstTime = nowTime 
          return  func.apply(this,args)
        }
    }
   }

   const func =function(e) {
        console.log(e.target.innerHTML)
   }
   let btn = document.getElementById('btn')
     btn.onclick =throttle1(func,1000)


// function slow(x) {
//   // 这里可能会有重负载的 CPU 密集型工作
//   alert(`Called with ${x}`);
//   return x;
// }

// function cachingDecorator(func) {
//   let cache = new Map();

//   return function(x) {
//     if (cache.has(x)) {    // 如果缓存中有对应的结果
//       debugger
//       return cache.get(x); // 从缓存中读取结果
//     }

//     let result = func(x);  // 否则就调用 func

//     cache.set(x, result);  // 然后将结果缓存（记住）下来
//     return result;
//   };
// }

// slow = cachingDecorator(slow);
// console.log( slow(1) ); // slow(1) 被缓存下来了
// console.log( "Again: " + slow(1) ); // 一样的

// alert( slow(2) ); // slow(2) 被缓存下来了
// alert( "Again: " + slow(2) ); // 和前面一行结果相同

// function work(a, b) {
//   console.log( a + b ); // work 是一个任意的函数或方法
// }
// function spy(func) {
//    function wrapper(...args) {
//      console.log(...args)
//     wrapper.calls.push(args)
//     func.apply(this,args) 
//   }
//   wrapper.calls = []
//   return wrapper
// }

// work = spy(work);


// work(1, 2); // 3
// work(4, 5); // 9
// for (let args of work.calls) {
//   console.log( 'call:' + args.join() ); // "call:1,2", "call:4,5"
// }

// function f(x) {
//   alert(x);
// }

// create wrappers
// let f1000 = delay(f, 1000);
// let f1500 = delay(f, 5000);
// function delay(func,time) {
//       return function (...args) {
//         setTimeout(() => {
//           func.apply(this,args)
//         }, time);
//       }
// }

// f1000("test"); // 在 1000ms 后显示 "test"
// f1500("test"); // 在 1500ms 后显示 "test"
let username = document.getElementById('userName')
let sm = document.getElementById('sm')
function keyWord(e) {
    console.log(e.target.value)
}
function debounce (func,interVal) {
      let time ;
      return function (...args) {
          clearInterval(time)
          time = setTimeout(() =>  func.call(this,...args)
          , interVal);
      }
}
username.onkeyup =debounce(keyWord,1000)
sm.onkeyup =keyWord



// function logData(a) {
//   console.log(a);
// }
// function throttle(func,interVal) {
//   let state = true
//   return function () {
//      let Timeout= setTimeout(() => {
//          state =true
//          clearTimeout(Timeout)
//        }, interVal);
//        if (state) {
//         func.apply(this,[...arguments])
//         state =false
//        }
//   }
//     //  let lastTime = new Date().getTime(),nowTime;
//     //  return function (...args) {
//     //    nowTime = new Date().getTime()
//     //    console.log(nowTime)
//     //         if(nowTime-lastTime>=interVal) {
//     //           lastTime = nowTime
//     //           return  func.apply(this,args)
//     //         }
//     //  }
// }
// // f1000 最多每 1000ms 将调用传递给 f 一次
// let f1000 = throttle(logData, 1000);

// f1000(1); // 显示 1
// f1000(2); // (节流，尚未到 1000ms)
// f1000(3);




// function f(a) {
//   console.log(a);
// }

// // f1000 最多每 1000ms 将调用传递给 f 一次
// let f1000 = throttle(f, 1000);

// f1000(1); // 显示 1
// f1000(2); // (节流，尚未到 1000ms)
// f1000(3); // (节流，尚未到 1000ms)
// f1000(4); // (节流，尚未到 1000ms)
// f1000(5); // (节流，尚未到 1000ms)
// f1000(6); // (节流，尚未到 1000ms)

// function throttle(func, ms) {

// let isThrottled = false,
//   saveArgs,
//   savedThis;

// function wrapper() {
//       if(isThrottled) {
//         savedThis =this
//         saveArgs = arguments
//           return
//       }
//       func.apply(this,[...arguments])
//       isThrottled = true
//       setTimeout(() => {
//           func.apply(savedThis,[...saveArgs])
//           isThrottled = false
//           savedThis = saveArgs = null
//       }, ms);
// }
// return wrapper;
// }

const func2 = (a,b) =>console.log(a+b)

Function.prototype.deir = (time)=> 
(...args)=>{
    setTimeout(() => {
      func2.apply(this,args)
  }, time);
  }
Function.deir(1000)(1,2)
</script>

</html>